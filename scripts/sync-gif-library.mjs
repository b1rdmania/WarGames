#!/usr/bin/env node
/**
 * Build a stable, themed library from approved GIF review picks.
 *
 * Output:
 * - public/gifs/library/<category>/<alias>.gif
 * - public/gifs/library/library.manifest.json
 * - src/lib/gif-library.ts
 */

import { existsSync, mkdirSync, readFileSync, readdirSync, rmSync, writeFileSync } from 'fs';
import crypto from 'crypto';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const ROOT = path.join(__dirname, '../public/gifs');
const APPROVED = path.join(ROOT, 'approved');
const CATALOG = path.join(ROOT, 'catalog.manifest.json');
const LIBRARY_DIR = path.join(ROOT, 'library');
const LIBRARY_MANIFEST = path.join(LIBRARY_DIR, 'library.manifest.json');
const LIBRARY_TS = path.join(__dirname, '../src/lib/gif-library.ts');

const DEFAULT_CATEGORY = 'retro';
const CATEGORY_RULES = [
  { category: 'markets', words: ['stats', 'statistics', 'matrix', 'number', 'numbers', 'countdown', 'counter', 'calculator', 'abacus', 'gauge', 'meter', 'oscilloscope', 'chart', 'graph', 'ticker', 'trend', 'stock', 'volatility', 'dollar', 'coin', 'cash', 'bank', 'vault', 'loading', 'indicator'] },
  { category: 'intel', words: ['radar', 'reticle', 'target', 'satellite', 'signal', 'map', 'terminal', 'classified', 'secure', 'encrypted'] },
  { category: 'threat', words: ['tank', 'missile', 'bomb', 'warning', 'alert', 'nuclear', 'skull', 'siren', 'explosion', 'fire', 'flame'] },
  { category: 'retro', words: ['web', 'guestbook', 'new-badge', 'netscape', 'under-construction', 'alien', 'ufo', 'scan', 'scope'] },
];

function readJson(file, fallback) {
  if (!existsSync(file)) return fallback;
  try {
    return JSON.parse(readFileSync(file, 'utf8'));
  } catch {
    return fallback;
  }
}

function normalizeAliasPart(value) {
  return value
    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');
}

function stripTrailingHash(id) {
  return id.replace(/-[A-Z0-9]{16,}$/i, '');
}

function detectCategory(id, query, themes = []) {
  const haystack = `${id} ${query ?? ''} ${themes.join(' ')}`.toLowerCase();
  for (const rule of CATEGORY_RULES) {
    if (rule.words.some(word => haystack.includes(word))) return rule.category;
  }
  return DEFAULT_CATEGORY;
}

function ensureDir(dir) {
  mkdirSync(dir, { recursive: true });
}

function listExistingLibraryGifs() {
  if (!existsSync(LIBRARY_DIR)) return [];
  const out = [];
  const stack = [LIBRARY_DIR];
  while (stack.length > 0) {
    const current = stack.pop();
    for (const entry of readdirSync(current, { withFileTypes: true })) {
      const abs = path.join(current, entry.name);
      if (entry.isDirectory()) stack.push(abs);
      else if (entry.isFile() && entry.name.toLowerCase().endsWith('.gif')) out.push(abs);
    }
  }
  return out;
}

function toWebPath(absPath) {
  const rel = path.relative(ROOT, absPath).split(path.sep).join('/');
  return `/gifs/${rel}`;
}

function toTs(entries) {
  const lines = [];
  lines.push('// Auto-generated by scripts/sync-gif-library.mjs');
  lines.push('// Do not edit directly.');
  lines.push('');
  lines.push("export type GifLibraryCategory = 'markets' | 'intel' | 'threat' | 'retro';");
  lines.push('');
  lines.push('export interface GifLibraryEntry {');
  lines.push('  id: string;');
  lines.push('  alias: string;');
  lines.push('  category: GifLibraryCategory;');
  lines.push('  path: string;');
  lines.push('  query: string | null;');
  lines.push('  themes: string[];');
  lines.push('}');
  lines.push('');
  lines.push('export const GIF_LIBRARY: GifLibraryEntry[] = [');
  for (const entry of entries) {
    lines.push(
      `  { id: ${JSON.stringify(entry.id)}, alias: ${JSON.stringify(entry.alias)}, category: ${JSON.stringify(entry.category)}, path: ${JSON.stringify(entry.path)}, query: ${JSON.stringify(entry.query)}, themes: ${JSON.stringify(entry.themes)} },`
    );
  }
  lines.push('];');
  lines.push('');
  lines.push('export const GIF_LIBRARY_BY_ALIAS = Object.fromEntries(');
  lines.push('  GIF_LIBRARY.map((item) => [item.alias, item])');
  lines.push(') as Record<string, GifLibraryEntry>;');
  lines.push('');
  lines.push('export const GIF_LIBRARY_BY_CATEGORY = GIF_LIBRARY.reduce((acc, item) => {');
  lines.push('  const existing = acc[item.category] ?? [];');
  lines.push('  existing.push(item);');
  lines.push('  acc[item.category] = existing;');
  lines.push('  return acc;');
  lines.push('}, {} as Record<GifLibraryCategory, GifLibraryEntry[]>);');
  lines.push('');
  return `${lines.join('\n')}\n`;
}

function listApprovedFiles() {
  if (!existsSync(APPROVED)) return [];
  return readdirSync(APPROVED, { withFileTypes: true })
    .filter(entry => entry.isFile() && entry.name.toLowerCase().endsWith('.gif'))
    .map(entry => path.join(APPROVED, entry.name))
    .sort();
}

function listLegacyRootFiles() {
  if (!existsSync(ROOT)) return [];
  return readdirSync(ROOT, { withFileTypes: true })
    .filter(entry => entry.isFile() && entry.name.toLowerCase().endsWith('.gif'))
    .map(entry => path.join(ROOT, entry.name))
    .sort();
}

function main() {
  const catalog = readJson(CATALOG, { entries: [] });
  const approvedFiles = listApprovedFiles();
  const legacyRootFiles = listLegacyRootFiles();

  // Keep approved files ahead of legacy root files so canonical picks prefer approved variants.
  const sourceFiles = [...approvedFiles, ...legacyRootFiles];

  if (sourceFiles.length === 0) {
    console.log('No source GIF files found (approved or legacy root).');
    return;
  }

  const catalogById = new Map(catalog.entries.map(entry => [entry.id, entry]));
  const aliasCount = new Map();
  const entries = [];
  const keptFiles = new Set();
  const seenSourceIds = new Set();
  const seenContentHashes = new Set();

  for (const sourceAbs of sourceFiles) {
    if (!existsSync(sourceAbs)) continue;
    const id = path.basename(sourceAbs).replace(/\.gif$/i, '');
    if (seenSourceIds.has(id)) continue;
    seenSourceIds.add(id);
    const raw = readFileSync(sourceAbs);
    const contentHash = crypto.createHash('sha1').update(raw).digest('hex');
    if (seenContentHashes.has(contentHash)) continue;
    seenContentHashes.add(contentHash);

    const sourceMeta = catalogById.get(id) ?? null;
    // Respect explicit/derived rejection. If no catalog entry exists, keep the file visible for manual final review.
    if (sourceMeta?.status === 'reject') continue;
    const baseName = stripTrailingHash(id);
    const category = detectCategory(id, sourceMeta?.query ?? null, sourceMeta?.themes ?? []);

    const baseAlias = normalizeAliasPart(baseName) || 'gif';
    const count = (aliasCount.get(`${category}/${baseAlias}`) ?? 0) + 1;
    aliasCount.set(`${category}/${baseAlias}`, count);
    const alias = count === 1 ? baseAlias : `${baseAlias}-${count}`;

    const targetDir = path.join(LIBRARY_DIR, category);
    ensureDir(targetDir);
    const targetAbs = path.join(targetDir, `${alias}.gif`);

    writeFileSync(targetAbs, raw);
    keptFiles.add(targetAbs);

    entries.push({
      id,
      alias,
      category,
      path: toWebPath(targetAbs),
      query: sourceMeta?.query ?? null,
      themes: sourceMeta?.themes ?? [],
    });
  }

  const stale = listExistingLibraryGifs().filter(abs => !keptFiles.has(abs));
  for (const abs of stale) rmSync(abs, { force: true });

  const byCategory = entries.reduce((acc, entry) => {
    acc[entry.category] = (acc[entry.category] ?? 0) + 1;
    return acc;
  }, {});

  ensureDir(LIBRARY_DIR);
  writeFileSync(
    LIBRARY_MANIFEST,
    JSON.stringify(
      {
        generatedAt: new Date().toISOString(),
        count: entries.length,
        categories: byCategory,
        entries,
      },
      null,
      2
    )
  );

  ensureDir(path.dirname(LIBRARY_TS));
  writeFileSync(LIBRARY_TS, toTs(entries));

  console.log(`Library synced: ${entries.length} GIFs`);
  console.log(`Source pools: approved=${approvedFiles.length}, legacyRoot=${legacyRootFiles.length}`);
  for (const [category, count] of Object.entries(byCategory)) {
    console.log(`- ${category}: ${count}`);
  }
  console.log(`Manifest: ${path.relative(process.cwd(), LIBRARY_MANIFEST)}`);
  console.log(`TypeScript index: ${path.relative(process.cwd(), LIBRARY_TS)}`);
}

main();
